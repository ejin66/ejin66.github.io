---
layout: post
title: 将Go代码编译成动态链接库，android通过JNI调用
tags: [Goland, Android, JNI]
---



很明显，要实现在Android上运行Go的代码，需要分两步走：

1. 将Go代码编译成动态链接库，也就是.so库
2. android 通过NDK调用so库，生成新的so库，通过JNI调用

<br/>

### 1. Go代码编译成动态链接库

将Go代码编译成动态链接库，可以通过下面的命令：

```bash
go build -buildmode=c-shared -o libxx.so xxx.go
```

其中，`-buildmode=c-shared` 表示编译模式为 动态链接， `-o libxx.so` 为生成指定的so，`xxx.go` 表示要进行编译的 go代码。

> 本文的编译环境是在windows下进行交叉编译

看似一行命令就行了，但是坑却很深：

1. 无法生成so库？
2. 生成了so库，但是没有头文件？
3. 搞定了上面的问题之后，尝试c代码调用so库一直失败？
4. android无法调用so库？设置go build参数，交叉编译linux下的so库失败？

针对以上问题，下面逐个进行分析。

<br/>

#### 1.1 无法生成so库

针对无法编译成so库的问题，我总结了几个可能的错误：

- 提示 `-buildmode=c-shared not supported on windows/amd64`

  `-buildmode=c-shared` 对go 版本有要求，go version >= 1.10

- 提示 `can't load package: package .: build constraints exclude all Go files in`

  需要先设置go env: `set CGO_ENABLED=1`

- 提示 `unimplemented: 64-bit mode not compiled in`

  不支持64位的编译，修改GOARCH： `set GOARCH=386`

<br/>

#### 1.2 生成了so库，但是没有头文件?

首先，看下go代码：

```go
package main

import "C"

func hello(message string) string {
	return "hello," + message
}

func main() {}
```

> 将go代码编译成c so库，需要import "C"。

很简单的一段代码，编译之后成功生成了so文件，却没有头文件。。。研究了半天，发现：只有通过注释 `export func` ，才会生成头文件（OS: 还有这种操作？！！）。修改下代码：

```go
package main

import "C"

//export hello
func hello(message string) string {
	return "hello," + message
}

func main() {}
```

重新跑一遍命令，发现so库跟头文件都生成了，第一个问题顺利解决。

生成的内容：

- libgodemo.so

- libgodemo.h

  ```c
  /* Code generated by cmd/cgo; DO NOT EDIT. */
  
  /* package command-line-arguments */
  
  
  #line 1 "cgo-builtin-prolog"
  
  #include <stddef.h> /* for ptrdiff_t below */
  
  #ifndef GO_CGO_EXPORT_PROLOGUE_H
  #define GO_CGO_EXPORT_PROLOGUE_H
  
  typedef struct { const char *p; ptrdiff_t n; } _GoString_;
  
  #endif
  
  /* Start of preamble from import "C" comments.  */
  
  
  
  
  /* End of preamble from import "C" comments.  */
  
  
  /* Start of boilerplate cgo prologue.  */
  #line 1 "cgo-gcc-export-header-prolog"
  
  #ifndef GO_CGO_PROLOGUE_H
  #define GO_CGO_PROLOGUE_H
  
  typedef signed char GoInt8;
  typedef unsigned char GoUint8;
  typedef short GoInt16;
  typedef unsigned short GoUint16;
  typedef int GoInt32;
  typedef unsigned int GoUint32;
  typedef long long GoInt64;
  typedef unsigned long long GoUint64;
  typedef GoInt32 GoInt;
  typedef GoUint32 GoUint;
  typedef __SIZE_TYPE__ GoUintptr;
  typedef float GoFloat32;
  typedef double GoFloat64;
  typedef float _Complex GoComplex64;
  typedef double _Complex GoComplex128;
  
  /*
    static assertion to make sure the file is being used on architecture
    at least with matching size of GoInt.
  */
  typedef char _check_for_32_bit_pointer_matching_GoInt[sizeof(void*)==32/8 ? 1:-1];
  
  typedef _GoString_ GoString;
  typedef void *GoMap;
  typedef void *GoChan;
  typedef struct { void *t; void *v; } GoInterface;
  typedef struct { void *data; GoInt len; GoInt cap; } GoSlice;
  
  #endif
  
  /* End of boilerplate cgo prologue.  */
  
  #ifdef __cplusplus
  extern "C" {
  #endif
  
  
  extern GoString hello(GoString p0);
  
  #ifdef __cplusplus
  }
  #endif
  ```

<br/>

#### 1.3 C代码调用so库一直失败？

原本生成了so库和头文件之后，直接拿去NDK生成so库的，但是发现一直失败，就怀疑是否是so库本身有问题，便决定先用C代码调一遍看看。

> 这里需要gcc编译环境，没有的话需要先安装

c代码调用so库：

```c
#include <stdio.h>
#include "libgodemo.h"

void main() {
	GoString gostring;
	gostring.p = "ejin";
	gostring.n = 4;
	printf("%s", hello(gostring).p);
}
```

gcc命令如下：

```bash
gcc test.c -L ./ -lgodemo -o test.exe
```

根据网上的描述，调用so库需要-L -l, 但是这种命令方式一直不行。最后，换成下面这种写法：

```bash
gcc test.c libgodemo.so -o test.exe
```

终于，成功的生成了 `test.exe`，迫不及待的在命令行上运行 `test.exe`，发现报错，真是命运坎坷啊！！！错误如下：

```bash
panic: runtime error: cgo result has Go pointer

goroutine 17 [running, locked to thread]:
main._cgoexpwrap_ebd98c1bdb5c_hello.func1(0x11433f6c)
        _cgo_gotypes.go:46 +0x50
main._cgoexpwrap_ebd98c1bdb5c_hello(0x405064, 0x3, 0x11456010, 0x9)
        _cgo_gotypes.go:48 +0x8a
```

仔细看下上面的头文件，发现在go代码中的`string`最后转成了 `GoString`，可能是go中的基本类型与c语言中的基本类型转换的问题。针对上面的错误，我还没有能够弄清楚，但是可以通过下面的写法来规避这种错误：

```go
package main

import "C"

//export hello
func hello(message string) *C.char {
	var s = C.CString("hello," + message)
	return s
}

func main() {}
```

就是不直接返回 `string`, 而是`*C.char`, 也就是C中的 `char*`。

重新编译一遍Go, 生成的头文件如下：

```c
/* Code generated by cmd/cgo; DO NOT EDIT. */

/* package command-line-arguments */


#line 1 "cgo-builtin-prolog"

#include <stddef.h> /* for ptrdiff_t below */

#ifndef GO_CGO_EXPORT_PROLOGUE_H
#define GO_CGO_EXPORT_PROLOGUE_H

typedef struct { const char *p; ptrdiff_t n; } _GoString_;

#endif

/* Start of preamble from import "C" comments.  */




/* End of preamble from import "C" comments.  */


/* Start of boilerplate cgo prologue.  */
#line 1 "cgo-gcc-export-header-prolog"

#ifndef GO_CGO_PROLOGUE_H
#define GO_CGO_PROLOGUE_H

typedef signed char GoInt8;
typedef unsigned char GoUint8;
typedef short GoInt16;
typedef unsigned short GoUint16;
typedef int GoInt32;
typedef unsigned int GoUint32;
typedef long long GoInt64;
typedef unsigned long long GoUint64;
typedef GoInt32 GoInt;
typedef GoUint32 GoUint;
typedef __SIZE_TYPE__ GoUintptr;
typedef float GoFloat32;
typedef double GoFloat64;
typedef float _Complex GoComplex64;
typedef double _Complex GoComplex128;

/*
  static assertion to make sure the file is being used on architecture
  at least with matching size of GoInt.
*/
typedef char _check_for_32_bit_pointer_matching_GoInt[sizeof(void*)==32/8 ? 1:-1];

typedef _GoString_ GoString;
typedef void *GoMap;
typedef void *GoChan;
typedef struct { void *t; void *v; } GoInterface;
typedef struct { void *data; GoInt len; GoInt cap; } GoSlice;

#endif

/* End of boilerplate cgo prologue.  */

#ifdef __cplusplus
extern "C" {
#endif


extern char* hello(GoString p0);

#ifdef __cplusplus
}
#endif
```

头文件中  `hello` 返回的类型由原来的 `GoString` 变成了 `char*`。

更改一下c代码：

```c
#include <stdio.h>
#include "libgodemo.h"

void main() {
	GoString gostring;
	gostring.p = "ejin";
	gostring.n = 4;
	printf("%s", hello(gostring));
}
```

gcc重新编译一遍，生成 `test.exe`， 并运行：

```bash
D:\go_c_jni>test.exe
hello,ejin
```

终于成功了。。。激动地热泪盈眶。。。

<br/>

#### 1.4 android无法调用so库？设置go build参数，交叉编译linux下的so库失败？

因为编译环境是 `windows`，所以肯定是不行的。修改go build的 env：

```bash
set GOARCH=arm
set GOOS=linux
```

> 修改完成后，可以通过 `go env` 查看详细参数配置

重新运行上面的 `go build -buildmode....` 命令，居然又报错了。。。

```bash
# runtime/cgo
gcc: error: unrecognized command line option '-marm'; did you mean '-mabm'?
```

又跑去google, 发现需要将 `go env cc`  设置为 `arm-linux-gnueabi-gcc`, 需要一个专业的交叉编译的gcc才行。修改go env:

```bash
set CC=arm-linux-gnueabi-gcc
```

重新运行命令，发现没有装 `arm-linux-gnueabi-gcc`。接着去下载，官网下载地址是：[arm-linux-gnueabi-gcc](https://releases.linaro.org/components/toolchain/binaries/latest/arm-linux-gnueabi/)。下载安装完成之后，配置下环境变量Path, 重新运行命令 `go build ...`。

终于，还是成功了。。。（一口老血喷出来）。。。

<br/>

### 2. NDK生成so库，JNI调用

经历重重艰险，成功的生成了so库，万里长征走了一半，希望下面能够一帆风顺。。。

>  关于用`NDK`生成so库，不了解的可以参考下：[NDK开发总结](https://ejin66.github.io/2018/01/08/android-ndk.html)。

目前进度：NDK调用该动态链接库总是失败。。。

so库的编译环境是 arm/linux， gcc是arm-linux-guneabi-gcc。

怀疑平台还有有差异，重新设置go build环境参数：

```bash
set GOARCH=arm
set GOOS=android
set CC=arm-linux-androideabi-gcc
set CGO_ENABLED=1
go build -buildmode=c-shared -o libgodemo.so godemo.go
```

其中 cc为 `arm-linux-androideabi-gcc`, 它是NDK自带的gcc，需要设置到 `PATH`中去。在NDK中的地址是：

`toolchains\arm-linux-androideabi-4.9\prebuilt\windows-x86_64\bin`。

设置完调用 `go build ...` 还是报错：

```bash
# runtime/cgo
_cgo_export.c:3:20: fatal error: stdlib.h: No such file or directory
 #include <stdlib.h>
                    ^
compilation terminated.
```

目前卡在这里，后续在更新。。。